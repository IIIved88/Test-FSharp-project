module Program
// For more information see https://aka.ms/fsharp-console-apps
printfn "Hello from F#"

open System //System это пространство имен, которое мы можем использовать в коде

// Для справки
//Спецификаторы формата printf ! нужны того, чтобы консоль понимала тип выводимых данных
//%c - Символ
//%s - Строка символов
//%d, i - Целое десятичное со знаком
//%o - Целое восьмеричное
//%u - Целое десятичное без знака
//%x, X - Целое шестнадцатеричное
//%f - Дробное число в фиксированном формате
//%e, E - Дробное число в научном формате
//%g, G - Дробное число в научном или фиксированном формате
//%p - Указатель (в шестнадцатеричном виде)

//Простые функции

let Name = "Daniil"
printfn "%s" Name

let Age = 28
printfn "Age:%d" Age



//Как работает иммутабельность

Name = "Kirill" //Хочу изменить аргумент, но он "immutable"
printfn "%s" Name

let mutable Name1 = "Daniil" //Для возможности изменения аргумента добавляем ключевое слово "mutable" и вместо "=" ставим оператор "<-"
printfn "%s" Name1
Name1 <- "Kirill" //"<-" это оператор изменений
printfn "%s" Name1



//Арифмитические операции

let x =10
let x1 = x+25
let x2 = x>x1
printfn $"{x2}" //Вместо того, чтобы использовать разные спецификаторы для консоли, можно делать так
                // и компилятор F# будет сам определять тип данных



//Функция со значением параметра типа "unit", который представляет пустые скобки

let ShowText() = printfn "Done" //Объявление функции с параметром (), т.е нам не важно что там за параметр
//let res = ShowText() //Вызываем функцию ShowText, через встроенную функцию "res" 

let ShowText1() = printfn "Done1"
ShowText1() //Вызываем функцию ShowText

let ShowMe = printfn "Primer" //Вывод простого значения
let ShowMe1() = printfn "Primer1"//Вывод функции
//let res = ShowMe1()



//Разница в отступах многострочных функций

let ShowUs()= 
  printfn "ShowUsResult"
  let ShowUs2 = "ShowUsResult2"
  printfn $"{ShowUs2}"
ShowUs()
ShowUs()

let ShowUs1()= 
  printfn "ShowUsResult1"
let ShowUs12 = "ShowUsResult12"
printfn $"{ShowUs12}"
ShowUs1()
ShowUs1()



//Объявление функции с параметром и вывод результата двумя способами

let Func a = printfn $"Result:{a}"
Func "Numbers1"
Func "Numbers2"
let res = Func "Numbers"
let res1 = Func "Numbers11"


let sum x y = 
   let res11 =  x * y
   printfn $"{res11}"
sum 1 2

let sum1 x y = x+y // объявление функции sum1
let res22 = sum1 2 3 // вызов функции sum1, результат вызова 5 передается res22, который будет хранить это значение
printfn$"{res22}"


//Игнорирование параметров, если параметр не используется

let printMessage _ = printfn "Hello"
printMessage()
printMessage ""
printMessage 1




//Вложеннын функции

let sum14 x y =         // Внутри функции sum14 определена функцией result
    printfn $"x = {x}" //Вывод значения в консоль
    printfn $"y = {y}" //Вывод значения в консоль
    let result = x + y //Функция определена, но не вызывается
    result             //Вызов функции 
let n = sum14 5 3
printfn $"n = {n}"




//Области видимости

let a = 5
let helloGlobal() = printfn "Global scope"
 
let outer() =       // область видимости функции outer
    let a = 15
    let inner() =   
        let a = 10// область видимости функции inner
        helloGlobal()         // обращение к фунции helloGlobal из глобального контекста
        printfn $"Inner scope. a: {a}"      // обращение к значению a из глобального контекста
 
    inner()
    printfn "Outer scope"
 
outer()




//Конструкции if..then..else..elif

let x23 = 8

if x23 > 10 then printfn "x больше 10" // если х>10, то в случае правды выводим текст
else printfn "x меньше или равен 10"//выводит текст в случае отрицательного результата (необязательно использовать)


let x12 = 8
 
if x12 > 10 then printfn "x больше 10"
elif x12 < 10 then printfn "x меньше 10" //дополнительное условие, можно добавлять хоть сколько (необязательно использовать)
else printfn "x равен 10"





///Цикл while..do

let mutable m1 = 1
let mutable n1 = 1
while m1 < 10 do              //Внешний цикл
    while n1 < 10 do          //Внутренний цикл
        printf $"{m1 * n1}\t" 
        n1 <- n1 + 1         //Итерационно добавляет к результату "n" +1 и записывает в строку, пока не дойдет до 9. В это время "m" не изменяется
    printfn ""               //По завершению цикла переносит новую итерацию на новую строку
    m1 <- m1 + 1             //По завершению цикла в меняет условия новой итерации, добавляет к "m" +1 
    n1 <- 1                  //По завершению цикла в меняет условия новой итерации, 'n" начинает опять с 1

    //Сначала работает внутренний цикл пока не дойдет до 9, потом исходные данные меняются m=2 n=1 и опять до 9, потом опять m=3 n=1
    // и т.д. пока внешний цикл не дойдет до 9 т.е. m=9






//Цикл For..to/downto

for m7 = 1 to 9 do             //Внешний цикл Цикл читается как: начальное число 1 прибавляем в каждую итерацию 1 (конечное число 9) и выполняем действие после "do"
      for n7 = 1 to 9 do       //Внутренний цикл Начиная с 1 к каждому последующему прибавляется единица (т.к. "to") конечно число 9
        printf $"{m7 * n7}\t"  
      printfn ""





//Цикл For..in
for m in 1..9 do            //Внешний цикл. Перебирает значения в соотвествии с последовательностью 1,2,3 прибавляя результату предыдущее значение и подставляются в "m".
    for n in 1..9 do        //Внутренний цикл. Перебирает значения в соотвествии с последовательностью 1,2,3 прибавляя результату предыдущее значение и подставляются в "n".
        printf $"{n * m} \t"
    printfn ""

//Последовательность может быть и не по порядку, например
for n77 in 1..3..9 do
        printf $"{n77} \t"

